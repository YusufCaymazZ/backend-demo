# CI/CD Pipeline for Gaming Backend Platform
# ===========================================================================
# This workflow runs on every push and pull request
# It performs code quality checks, runs tests, and can deploy to production
#
# WHAT IS CI/CD?
# - CI (Continuous Integration): Automatically test code when developers push changes
# - CD (Continuous Deployment): Automatically deploy code after tests pass
#
# WHY USE CI/CD?
# - Catch bugs before they reach production
# - Ensure code quality standards are maintained
# - Automate repetitive tasks
# - Speed up development and deployment
# ===========================================================================

name: CI/CD Pipeline

# WHEN TO RUN THIS WORKFLOW
# ---------------------------------------------------------------------------
# "on" defines the trigger events that start this workflow
on:
  # Run on every push to any branch
  push:
    branches:
      - main          # Production branch
      - develop       # Development branch
      - 'feature/**'  # Any feature branch

  # Run on pull requests targeting main or develop
  pull_request:
    branches:
      - main
      - develop

  # Allow manual triggering from GitHub UI
  workflow_dispatch:

# ENVIRONMENT VARIABLES
# ---------------------------------------------------------------------------
# These variables are available to all jobs
env:
  PYTHON_VERSION: '3.11'

# JOBS - The actual work to be done
# ---------------------------------------------------------------------------
# Jobs run in parallel by default unless you specify dependencies
jobs:

  # JOB 1: CODE QUALITY CHECKS
  # -------------------------------------------------------------------------
  # This job checks if code follows style guidelines (linting)
  lint:
    name: Code Quality & Linting
    runs-on: ubuntu-latest  # Use Ubuntu Linux virtual machine

    steps:
      # STEP 1: Get the code
      - name: Checkout code
        uses: actions/checkout@v4  # This is a pre-built action from GitHub
        # "uses" means we're using someone else's action (like importing a library)

      # STEP 2: Set up Python environment
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'  # Cache pip packages to speed up future runs

      # STEP 3: Install linting tools
      - name: Install linting dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black
        # "run" executes shell commands (like running commands in terminal)

      # STEP 4: Run flake8 (checks for code style violations)
      - name: Lint with flake8
        run: |
          # Stop the build if there are Python syntax errors or undefined names
          flake8 app/ scripts/ --count --select=E9,F63,F7,F82 --show-source --statistics
          # Check for other style issues (warning only, doesn't fail the build)
          flake8 app/ scripts/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      # STEP 5: Check code formatting with Black
      - name: Check code formatting
        run: black --check app/ scripts/

  # JOB 2: UNIT TESTS
  # -------------------------------------------------------------------------
  # This job runs your test suite to verify code correctness
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: lint  # This job waits for 'lint' job to finish
    # "needs" creates a dependency - tests only run if linting passes

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov  # Testing framework + coverage tool

      - name: Run unit tests with coverage
        run: |
          # Run pytest with coverage report
          pytest tests/ --cov=app --cov=scripts --cov-report=xml --cov-report=term
          # --cov: measure code coverage
          # --cov-report=xml: generate XML report for code coverage tools
          # --cov-report=term: show coverage in terminal

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          fail_ci_if_error: false  # Don't fail if coverage upload fails
        # This uploads coverage to codecov.io (optional service)

      # Save test results as artifacts (downloadable files)
      - name: Upload test results
        if: always()  # Run even if previous steps failed
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            coverage.xml
            .pytest_cache/

  # JOB 3: SECURITY SCANNING
  # -------------------------------------------------------------------------
  # Check for known security vulnerabilities in dependencies
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install safety bandit

      - name: Check for known vulnerabilities in dependencies
        run: |
          # Safety checks your dependencies against a database of known vulnerabilities
          pip install -r requirements.txt
          safety check --json || true  # || true means don't fail the build

      - name: Run Bandit security linter
        run: |
          # Bandit finds common security issues in Python code
          bandit -r app/ scripts/ -f json -o bandit-report.json || true

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            bandit-report.json

  # JOB 4: BUILD DOCKER IMAGE
  # -------------------------------------------------------------------------
  # Build the Docker container to ensure it builds successfully
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [test, security]  # Wait for both test and security jobs

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up Docker Buildx (advanced Docker builder)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Build the Docker image
      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: false  # Don't push to registry, just build
          tags: gaming-backend:${{ github.sha }}  # Tag with git commit hash
          cache-from: type=gha  # Use GitHub Actions cache
          cache-to: type=gha,mode=max

      # Test that the Docker image works
      - name: Test Docker image
        run: |
          docker build -t test-image .
          docker run -d --name test-container -p 8000:8000 \
            -e JWT_SECRET=test_secret_for_ci_only_min_32_chars_required \
            -e DATABASE_URL=sqlite:////app/data/app.db \
            test-image

          # Wait for container to be healthy (max 60 seconds)
          echo "Waiting for container to start..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health 2>/dev/null; then
              echo "Container is healthy!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Container failed to start. Logs:"
              docker logs test-container
              docker stop test-container
              exit 1
            fi
            echo "Attempt $i/30: Container not ready yet, waiting 2s..."
            sleep 2
          done

          # Run final health check
          curl --fail http://localhost:8000/health
          docker stop test-container

  # JOB 5: DEPLOYMENT (Only on main branch)
  # -------------------------------------------------------------------------
  # This job deploys to production when code is merged to main
  # IMPORTANT: This is a template - you need to configure your deployment target
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    # Only run on main branch AND when it's a push (not a pull request)
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    # Production deployments need approval (configure in GitHub settings)
    environment:
      name: production
      url: https://your-game-backend.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ==================================================================
      # DEPLOYMENT OPTIONS - Choose one based on your infrastructure
      # ==================================================================

      # OPTION 1: Deploy to AWS EC2
      # ------------------------------------------------------------
      # - name: Deploy to AWS EC2
      #   env:
      #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #   run: |
      #     # SSH into EC2 and pull latest code
      #     ssh -i key.pem ubuntu@your-server.com << 'EOF'
      #       cd /app
      #       git pull origin main
      #       docker-compose down
      #       docker-compose up -d --build
      #     EOF

      # OPTION 2: Deploy to Heroku
      # ------------------------------------------------------------
      # - name: Deploy to Heroku
      #   uses: akhileshns/heroku-deploy@v3.12.12
      #   with:
      #     heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
      #     heroku_app_name: "your-app-name"
      #     heroku_email: "your-email@example.com"

      # OPTION 3: Deploy to Docker Registry + Kubernetes
      # ------------------------------------------------------------
      # - name: Login to Docker Hub
      #   uses: docker/login-action@v2
      #   with:
      #     username: ${{ secrets.DOCKER_USERNAME }}
      #     password: ${{ secrets.DOCKER_PASSWORD }}
      #
      # - name: Build and push Docker image
      #   uses: docker/build-push-action@v4
      #   with:
      #     push: true
      #     tags: yourusername/gaming-backend:latest
      #
      # - name: Deploy to Kubernetes
      #   run: |
      #     kubectl set image deployment/gaming-backend \
      #       gaming-backend=yourusername/gaming-backend:latest

      # PLACEHOLDER: Print deployment message
      - name: Deployment placeholder
        run: |
          echo "Deployment would happen here"
          echo "Configure your deployment target in this job"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"

# ===========================================================================
# HOW TO SET UP SECRETS
# ===========================================================================
# Secrets are encrypted environment variables stored in GitHub
#
# To add secrets:
# 1. Go to your GitHub repository
# 2. Click Settings > Secrets and variables > Actions
# 3. Click "New repository secret"
# 4. Add secrets like:
#    - JWT_SECRET_PROD (production JWT secret)
#    - AWS_ACCESS_KEY_ID (for AWS deployment)
#    - DOCKER_PASSWORD (for Docker Hub)
#
# Use secrets in workflow: ${{ secrets.SECRET_NAME }}
# ===========================================================================

# ===========================================================================
# HOW TO MONITOR THIS WORKFLOW
# ===========================================================================
# 1. Go to your repository on GitHub
# 2. Click the "Actions" tab
# 3. You'll see all workflow runs
# 4. Click on a run to see details and logs
# 5. Green checkmark = success, Red X = failure
# ===========================================================================
